# [Codeforces Global Round 23](https://codeforces.com/contest/1746)

## A

只要有 1 就行

## B

把前面的 1 放在后面 0 的位置，双向奔赴

## C

在 $i$ 后面所有数都加 $i$ 那么 $i$ 位置必然小于后面所有位置。所以总有方式可以让最终逆序数为 0

## D

树上 DP，根据考虑到儿子节点的 path 差异最大为 1，所以儿子平分，多出来的在增加一个后按照权重排序，取最大的几个

## F

> 我一开始还以为所有数是 $k$ 的倍数，我说咋这么简单。。。原来是所有数出现的次数

好套路啊！直接概率大法，把每个值改称其它随机值，然后看区间和是否是 $k$ 的倍数。离散化，然后每次安排不一样的数组（如果不想离散化可以多一个 log 的复杂度），然后看用数状数组求区间和