# [Codeforces Global Round 23](https://codeforces.com/contest/1746)

## A

只要有 1 就行

## B

把前面的 1 放在后面 0 的位置，双向奔赴

## C

在 $i$ 后面所有数都加 $i$ 那么 $i$ 位置必然小于后面所有位置。所以总有方式可以让最终逆序数为 0

## D

树上 DP，根据考虑到儿子节点的 path 差异最大为 1，所以儿子平分，多出来的在增加一个后按照权重排序，取最大的几个

